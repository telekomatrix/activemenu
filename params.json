{"name":"Activemenu","tagline":"A toolkit for menus","body":"![ActiveMenu Logo](https://raw.github.com/sadjow/activemenu/master/activemenu_logo.png)\r\n\r\n[![Gem Version](https://fury-badge.herokuapp.com/rb/activemenu.png)](http://badge.fury.io/rb/activemenu)\r\n[![Build Status](https://travis-ci.org/sadjow/activemenu.png)](https://travis-ci.org/sadjow/activemenu)\r\n[![Dependency Status](https://gemnasium.com/sadjow/activemenu.png)](https://gemnasium.com/sadjow/activemenu)\r\n[![Code Climate](https://codeclimate.com/github/sadjow/activemenu.png)](https://codeclimate.com/github/sadjow/activemenu)\r\n\r\nCreate menus with multi-level and a Domain Specific Language (DSL) for menus.\r\nIt's extremely Object Oriented. It still doesn't have code for render, but you can combine it with\r\nother mechanism for rendering, like simple-navigation or other.\r\n\r\n## Semantic Versioning (http://semver.org/)\r\nThis gem is following the [Semantic Versioning](http://semver.org/)\r\n\r\n## Features\r\n  * Compatible with any application or framework.\r\n  * Singleton registry for menus (ActiveMenu::Registry), you can define menus anywhere. (But, use your conscience to a good design.)\r\n  * Domain Specific Language\r\n  * You can define the menu along multiple gems(like plugins of Rails)\r\n\r\n## Some wiki\r\n[Using simple-navigation with activemenu](https://github.com/sadjow/activemenu/wiki/Using-simple-navigation-for-render-the-activemenu)\r\n\r\n## Initial example\r\n```ruby\r\n  ActiveMenu::create('admix-nav') do |nav|        \r\n          \r\n    nav.child :dashboard do |dashboard|\r\n      dashboard.text = Proc.new { t('dashboard.dashboard') }\r\n      dashboard.href = Proc.new { admix_root_url }\r\n      dashboard.icon = 'icon-flag'\r\n    end\r\n\r\n    nav.child :general do |general|\r\n      general.text = Proc.new { t('general.general') }\r\n      general.icon = 'icon-flag'\r\n      general.href = 'javascript:;'\r\n      general.visible = Proc.new {current_user.has_role?(:admin)}\r\n    end\r\n\r\n    nav.child :content do |content|\r\n      content.text = Proc.new { t('content.content') }\r\n      content.href = 'javascript:;'\r\n      content.icon = 'icon-flag'\r\n    end\r\n\r\n  end\r\n```\r\n\r\n## Installation\r\n\r\nAdd this line to your application's Gemfile:\r\n\r\n    gem 'activemenu'\r\n\r\nAnd then execute:\r\n\r\n    $ bundle\r\n\r\nOr install it yourself as:\r\n\r\n    $ gem install activemenu\r\n\r\n## Usage\r\n\r\n### Creating menus objects in the registry\r\n\r\n```ruby\r\nActiveMenu::create(:mymenu)\r\n#....\r\n# In another gem you can use \r\n@menu = ActiveMenu::get(:mymenu).child do |sub|\r\n  sub.content = 'My content'\r\nend\r\n```\r\n### exists?\r\n```ruby\r\n  ActiveMenu::create(:someid)\r\n  ActiveMenu::exists?(:someid) # == true\r\n  ActiveMenu::exists?(:this_id_doesnt_exists) # == false\r\n``` \r\n\r\n### visible\r\n```ruby\r\n  ActiveMenu::get(:someid).visible\r\n```\r\n\r\n### Get the menu\r\nYou can retrieve the menu instance with the method get...\r\n```ruby\r\n  @menu = ActiveMenu::get(:someid)\r\n```\r\n\r\nor, you can use a block too and retrieve it as the first param.\r\n\r\n```ruby\r\n  ActiveMenu::get(:someid) do |menu|\r\n    menu.id # The menu id\r\n  end\r\n```\r\n\r\n### Set options to the menu\r\nThese options are write to a hash, that you can use with other gem to render it.\r\n```ruby\r\n  @menu = ActiveMenu::get(:someid)\r\n  @menu.myoption = 'my value'\r\n  @menu.myoption2 = Proc.new { my_dynamic_method #that will run when I use this option }\r\n```\r\n\r\n## Standard DSL (Domain Specific Language) options\r\n\r\nTo facilitate the creating of menus, there are some methods to help you organize the options standard.\r\n\r\n### visible(value=nil)\r\nYou can pass a variable or a Proc to be executed to the visible method.\r\n```ruby\r\n  ActiveMenu::create('admix-nav') do |nav|        \r\n    nav.child :general do |general|\r\n      general.text = Proc.new { t('general.general') }\r\n      general.icon = 'icon-flag'\r\n      general.visible = Proc.new {current_user.has_role? :admin}\r\n    end\r\n  end\r\n\r\nend\r\n```\r\n\r\n### tag(value=nil)\r\nYou can set the tag for the menu element or can retrieve it.\r\n```ruby\r\n    @menu = ActiveMenu::get(:my_menu)\r\n    @menu.tag = :li\r\n    @menu.tag # --> :li\r\n    @menu.tag = :div\r\n    @menu.tag # --> :div\r\n```\r\n\r\n### text()\r\n\r\n### Nested menus\r\n```ruby\r\n@menu = ActiveMenu::Menu.new(:mainmenu, href: 'http://example.com') \r\n# def initialize(id, options={}, &block) .... yield(self) if block_given?\r\n@menu.child(:mychild, href: \"test\") do |sm|\r\n  sm.text = 'My child'\r\n  sm.child(:mysubchild, href:'test 2') do |ssm|\r\n    ssm.text = 'My subchild'\r\n  end\r\nend\r\n# Let's improve this DSL, contribute please.\r\n```\r\n\r\n\r\n## Contributing\r\n\r\n1. Fork it\r\n2. Create your feature branch (`git checkout -b my-new-feature`)\r\n3. Commit your changes (`git commit -am 'Add some feature'`)\r\n4. Push to the branch (`git push origin my-new-feature`)\r\n5. Create new Pull Request\r\n","google":"UA-40055802-1","note":"Don't delete this file! It's used internally to help with page regeneration."}